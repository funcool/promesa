<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>User Guide</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Promesa</span> <span class="project-version"></span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="user-guide.html"><div class="inner"><span>User Guide</span></div></a></li><li class="depth-1 "><a href="promises.html"><div class="inner"><span>Working with Promises</span></div></a></li><li class="depth-1 "><a href="executors.html"><div class="inner"><span>Scheduling &amp; Executors</span></div></a></li><li class="depth-1 "><a href="patterns.html"><div class="inner"><span>Execution Patterns</span></div></a></li><li class="depth-1 "><a href="contributing.html"><div class="inner"><span>Contributing</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>promesa</span></div></div></li><li class="depth-2 branch"><a href="promesa.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><a href="promesa.exec.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>exec</span></div></a></li><li class="depth-3 branch"><a href="promesa.exec.bulkhead.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bulkhead</span></div></a></li><li class="depth-3"><a href="promesa.exec.csp.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>csp</span></div></a></li><li class="depth-4 branch"><a href="promesa.exec.csp.buffers.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>buffers</span></div></a></li><li class="depth-4 branch"><a href="promesa.exec.csp.channel.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>channel</span></div></a></li><li class="depth-4"><a href="promesa.exec.csp.mutable-list.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>mutable-list</span></div></a></li><li class="depth-2"><a href="promesa.protocols.html"><div class="inner"><span class="tree" style="top: -176px;"><span class="top" style="height: 185px;"></span><span class="bottom"></span></span><span>protocols</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#user-guide" id="user-guide"></a>User Guide</h1>
<p>A promise library &amp; async toolkit for Clojure and ClojureScript.</p>
<h2><a href="#install" id="install"></a>Install</h2>
<p>Leiningen:</p>
<p>deps.edn:</p>
<pre><code class="language-clojure">funcool/promesa {:mvn/version "9.0.518"}
</code></pre>
<pre><code class="language-clojure">[funcool/promesa "9.0.518"]
</code></pre>
<h2><a href="#working-with-promises" id="working-with-promises"></a>Working with <code>promises</code></h2>
<p>A <strong>promise</strong> is an abstraction that represents the result of an asynchronous operation that has the notion of error. Backedn with <a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/util/concurrent/CompletableFuture.html">CompletebleFuture</a> on the JVM and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> on JS.</p>
<p>This is a list of all possible states for a promise:</p>
<ul>
<li><code>resolved</code>: means that the promise contains a value.</li>
<li><code>rejected</code>: means that the promise contains an error.</li>
<li><code>pending</code>: means that the promise does not have value.</li>
</ul>
<p>The promise can be considered <em>done</em> when it is resolved or rejected.</p>
<p><strong>NOTE:</strong> keep in mind that the vast majority of things work identically regardless of the runtime, but there are cases where the limitations of the platform implementation imply differences or even the omission of some functions.</p>
<h3><a href="#creating-a-promise" id="creating-a-promise"></a>Creating a promise</h3>
<p>There are several different ways to create a promise instance. If you just want to create a promise with a plain value, you can use the polymorphic <code>promise</code> function:</p>
<pre><code class="language-clojure">(require '[promesa.core :as p])

;; creates a promise from value
(p/promise 1)

;; creates a rejected promise
(p/promise (ex-info "error" {}))
</code></pre>
<p>It automatically coerces the provided value to the appropriate promise instance: <code>rejected</code> when the provided value is an exception and <code>resolved</code> in all other cases.</p>
<p>If you already know that the value is either <code>resolved</code> or <code>rejected</code>, you can skip the coercion and use the <code>resolved</code> and <code>rejected</code> functions:</p>
<pre><code class="language-clojure">;; Create a resolved promise
(p/resolved 1)
;; =&gt; #object[java.util.concurrent.CompletableFuture 0x3e133219 "resolved"]

;; Create a rejected promise
(p/rejected (ex-info "error" {}))
;; =&gt; #object[java.util.concurrent.CompletableFuture 0x3e563293 "rejected"]
</code></pre>
<p>Another option is to create an empty promise using the <code>deferred</code> function and provide the value asynchronously using <code>p/resolve!</code> and <code>p/reject!</code>:</p>
<pre><code class="language-clojure">(defn sleep
  [ms]
  (let [p (p/deferred)]
    (future (p/resolve! p))
    p))
</code></pre>
<p>Another option is using a factory function. If you are familiar with JavaScript, this is a similar approach:</p>
<pre><code class="language-clojure">@(p/create (fn [resolve reject] (resolve 1)))
;; =&gt; 1
</code></pre>
<p><strong>NOTE:</strong> the <code>@</code> reader macro only works on JVM.</p>
<p>The factory will be executed synchronously (in the current thread) but if you want to execute it asynchronously, you can provide an executor (JVM only):</p>
<pre><code class="language-clojure">(require '[promesa.exec :as exec])

@(p/create (fn [resolve reject] (resolve 1)) exec/default-executor)
;; =&gt; 1
</code></pre>
<p>Another way to create a promise is using the <code>do</code> macro:</p>
<pre><code class="language-clojure">(p/do
  (let [a (rand-int 10)
        b (rand-int 10)]
    (+ a b)))
</code></pre>
<p>The <code>do</code> macro works similarly to clojure’s <code>do</code> block, so you can provide any expression, but only the last one will be returned. That expression can be a plain value or another promise.</p>
<p>If an exception is raised inside the <code>do</code> block, it will return the rejected promise instead of re-raising the exception on the stack.</p>
<p>If the <code>do</code> contains more than one expression, each expression will be treated as a promise expression and will be executed sequentially, each awaiting the resolution of the prior expression.</p>
<p>For example, this <code>do</code> macro:</p>
<pre><code class="language-clojure">(p/do (expr1)
      (expr2)
      (expr3))
</code></pre>
<p>Is roughtly equivalent to <code>let</code> macro (explained below):</p>
<pre><code class="language-clojure">(p/let [_ (expr1)
        _ (expr2)]
  (expr3))
</code></pre>
<p>Finally, <em>promesa</em> exposes a <code>future</code> macro very similar to the <code>clojure.core/future</code>:</p>
<pre><code class="language-clojure">@(p/future (some-complex-task))
;; =&gt; "result-of-complex-task"
</code></pre>
<h3><a href="#chaining-computatons" id="chaining-computatons"></a>Chaining computatons</h3>
<p>This section explains the helpers and macros that <strong>promesa</strong> provides for chain different (high-probably asynchonous) operations in a sequence of operations.</p>
<h3><a href="#then" id="then"></a><code>then</code></h3>
<p>The most common way to chain a transformation to a promise is using the general purpose <code>then</code> function:</p>
<pre><code class="language-clojure">@(-&gt; (p/resolved 1)
     (p/then inc))
;; =&gt; 2

;; flatten result
@(-&gt; (p/resolved 1)
     (p/then (fn [x] (p/resolved (inc x)))))
;; =&gt; 2
</code></pre>
<p>As you can observe in the example, <code>then</code> handles functions that return plain values as well as functions that return promise instances (which will automatically be flattened).</p>
<p><strong>NOTE</strong>: If you know that the chained function will always return plain values, you can use the more performant <code>then'</code> variant of this function.</p>
<h3><a href="#map" id="map"></a><code>map</code></h3>
<p>The <code>map</code> function works similarly to the <code>then'</code> function, the difference is the order of arguments:</p>
<pre><code class="language-clojure">(def result
  (-&gt;&gt; (p/resolved 1)
       (p/map inc)))

@result
;; =&gt; 2
</code></pre>
<h3><a href="#chain" id="chain"></a><code>chain</code></h3>
<p>If you have multiple transformations and you want to apply them in one step, there are the <code>chain</code> and <code>chain'</code> functions:</p>
<pre><code class="language-clojure">(def result
  (-&gt; (p/resolved 1)
      (p/chain inc inc inc)))

@result
;; =&gt; 4
</code></pre>
<p><strong>NOTE</strong>: <code>chain</code> is analogous to <code>then</code> and <code>then'</code> but accept multiple transformation functions.</p>
<h3><a href="#-and-as-macros" id="-and-as-macros"></a><code>-&gt;</code>, <code>-&gt;&gt;</code> and <code>as-&gt;</code> (macros)</h3>
<p><strong>NOTE</strong>: <code>-&gt;</code> and <code>-&gt;&gt;</code> introduced in 6.1.431, <code>as-&gt;</code> introduced in 6.1.434.</p>
<p>This threading macros simplifices chaining operation, removing the need of using <code>then</code> all the time.</p>
<p>Lets look an example using <code>then</code> and later see how it can be improved using the <code>-&gt;</code> threading macro:</p>
<pre><code class="language-clojure">(-&gt; (p/resolved {:a 1 :c 3})
    (p/then #(assoc % :b 2))
    (p/then #(dissoc % :c)))
</code></pre>
<p>Then, the same code can be simplified with:</p>
<pre><code class="language-clojure">(p/-&gt; (p/resolved {:a 1 :c 3})
      (assoc :b 2))
      (dissoc :c))
</code></pre>
<p>The threading macros hides all the accidental complexity of using promise chaining.</p>
<p>The <code>-&gt;&gt;</code> and <code>as-&gt;</code> are equivalent to the clojure.core macros, but they work with promises in the same way as <code>-&gt;</code> example shows.</p>
<h3><a href="#handle" id="handle"></a><code>handle</code></h3>
<p>If you want to handle rejected and resolved callbacks in one unique callback, then you can use the <code>handle</code> chain function:</p>
<pre><code class="language-clojure">(def result
  (-&gt; (p/promise 1)
      (p/handle (fn [result error]
                  (if error :rejected :resolved)))))

@result
;; =&gt; :resolved
</code></pre>
<h3><a href="#finally" id="finally"></a><code>finally</code></h3>
<p>And finally if you want to attach a (potentially side-effectful) callback to be always executed notwithstanding if the promise is rejected or resolved, there is a executed regardless of whether the promise is rejected or resolved, there is a <code>finally</code> function (very similar to try/finally):</p>
<pre><code class="language-clojure">(def result
  (-&gt; (p/promise 1)
      (p/finally (fn [_ _]
                  (println "finally")))))

@result
;; =&gt; 1
;; =&gt; stdout: "finally"
</code></pre>
<h3><a href="#composition" id="composition"></a>Composition</h3>
<h3><a href="#let" id="let"></a><code>let</code></h3>
<p>The <em>promesa</em> library comes with convenient syntactic-sugar that allows you to create a composition that looks like synchronous code while using the Clojure’s familiar <code>let</code> syntax:</p>
<pre><code class="language-clojure">(require '[promesa.core :as p]
         '[promesa.exec :as px])

;; A function that emulates asynchronos behavior.
(defn sleep
  [wait]
  (p/create (fn [resolve reject]
              (px/schedule! wait #(resolve wait)))))

(def result
  (p/let [x (sleep 42)
          y (sleep 41)
          z 2]
    (+ x y z)))

@result
;; =&gt; 85
</code></pre>
<p>The <code>let</code> macro behaves identically to Clojure’s <code>let</code> with the exception that it always returns a promise. If an error occurs at any step, the entire composition will be short-circuited, returning exceptionally resolved promise.</p>
<p>Under the hood, the <code>let</code> macro evalutes to something like this:</p>
<pre><code class="language-clojure">(p/then
  (sleep 42)
  (fn [x]
    (p/then
      (sleep 41)
      (fn [y]
        (p/then
          2
          (fn [z]
            (p/promise (do (+ x y z)))))))))
</code></pre>
<h3><a href="#all" id="all"></a><code>all</code></h3>
<p>In some circumstances you will want wait for completion of several promises at the same time. To help with that, <em>promesa</em> also provides the <code>all</code> helper.</p>
<pre><code class="language-clojure">(let [p (p/all [(do-some-io)
                (do-some-other-io)])]
  (p/then p (fn [[result1 result2]]
              (do-something-with-results result1 result2))))
</code></pre>
<h3><a href="#plet-macro" id="plet-macro"></a><code>plet</code> macro</h3>
<p>The <code>plet</code> macro combines syntax of <code>let</code> with <code>all</code>; and enables a simple declaration of parallel operations followed by a body expression that will be executed when all parallel operations have successfully resolved.</p>
<pre><code class="language-clojure">@(p/plet [a (p/delay 100 1)
          b (p/delay 200 2)
          c (p/delay 120 3)]
   (+ a b c))
;; =&gt; 6
</code></pre>
<p>The <code>plet</code> macro is just a syntactic sugar on top of <code>all</code>. The previous example can be written using <code>all</code> in this manner:</p>
<pre><code class="language-clojure">(p/all [(p/delay 100 1)
        (p/delay 200 2)
        (p/delay 120 3)]
  (fn [[a b c]] (+ a b c)))
</code></pre>
<p>The real parallelism strictly depends on the underlying implementation of the executed functions. If they does syncrhonous work, all the code will be executed serially, almost identical to the standard let. Is the user responsability of the final execution model.</p>
<h3><a href="#any" id="any"></a><code>any</code></h3>
<p>There are also circumstances where you only want the first successfully resolved promise. For this case, you can use the <code>any</code> combinator:</p>
<pre><code class="language-clojure">(let [p (p/any [(p/delay 100 1)
                (p/delay 200 2)
                (p/delay 120 3)])]
  (p/then p (fn [x]
              (.log js/console "The first one finished: " x))))
</code></pre>
<h3><a href="#race" id="race"></a><code>race</code></h3>
<p>The <code>race</code> function method returns a promise that fulfills or rejects as soon as one of the promises in an iterable fulfills or rejects, with the value or reason from that promise:</p>
<pre><code class="language-clojure">@(p/race [(p/delay 100 1)
          (p/delay 110 2)])
;; =&gt; 1
</code></pre>
<h3><a href="#error-handling" id="error-handling"></a>Error handling</h3>
<p>One of the advantages of using the promise abstraction is that it natively has a notion of errors, so you don’t need to reinvent it. If some computation inside the composed promise chain/pipeline raises an exception, the pipeline short-circuits and propagates the exception to the last promise in the chain.</p>
<p>The <code>catch</code> function adds a new handler to the promise chain that will be called when any of the previous promises in the chain are rejected or an exception is raised. The <code>catch</code> function also returns a promise that will be resolved or rejected depending on what happens inside the catch handler.</p>
<p>Let see an example:</p>
<pre><code class="language-clojure">(-&gt; (p/rejected (ex-info "error" nil))
    (p/catch (fn [error]
               (.log js/console error))))
</code></pre>
<p>If you prefer <code>map</code>-like parameter ordering, the <code>err</code> function (and <code>error</code> alias) works in same way as <code>catch</code> but has parameters ordered like <code>map</code>:</p>
<pre><code class="language-clojure">(-&gt;&gt; (p/rejected (ex-info "error" nil))
     (p/error (fn [error]
                (.log js/console error))))
</code></pre>
<h3><a href="#delays-and-timeouts" id="delays-and-timeouts"></a>Delays and Timeouts.</h3>
<p>JavaScript, due to its single-threaded nature, does not allow you to block or sleep. But, with promises you can emulate that functionality using <code>delay</code> like so:</p>
<pre><code class="language-clojure">(-&gt; (p/delay 1000 "foobar")
    (p/then (fn [v]
              (println "Received:" v))))

;; After 1 second it will print the message
;; to the console: "Received: foobar"
</code></pre>
<p>The promise library also offers the ability to add a timeout to async operations thanks to the <code>timeout</code> function:</p>
<pre><code class="language-clojure">(-&gt; (some-async-task)
    (p/timeout 200)
    (p/then #(println "Task finished" %))
    (p/catch #(println "Timeout" %)))
</code></pre>
<p>In this example, if the async task takes more that 200ms then the promise will be rejected with a timeout error and then successfully captured with the <code>catch</code> handler.</p>
<h3><a href="#promise-chaining-execution-model" id="promise-chaining-execution-model"></a>Promise chaining &amp; execution model</h3>
<p>Let’s try to understand how promise chained functions are executed and how they interact with platform threads. **This section is mainly affects the <strong>JVM</strong>.</p>
<p>Lets consider this example:</p>
<pre><code class="language-clojure">@(-&gt; (p/delay 100 1)
     (p/then' inc)
     (p/then' inc))
;; =&gt; 3
</code></pre>
<p>This will create a promise that will resolve to <code>1</code> in 100ms (in a separate thread); then the first <code>inc</code> will be executed (in the same thread), and then another <code>inc</code> is executed (in the same thread). In total only one thread is involved.</p>
<p>This default execution model is usually preferrable because it don’t abuse the task scheduling and leverages function inlining on the JVM.</p>
<p>But it does have drawbacks: this approach will block the thread until all of the chained callbacks are executed. For small chains this is not a problem. However, if your chain has a lot of functions and requires a lot of computation time, this might cause unexpected latency. It may block other threads in the thread pool from doing other, maybe more important, tasks.</p>
<p>For such cases, <em>promesa</em> exposes an additional arity for provide a user-defined executor to control where the chained callbacks are executed:</p>
<pre><code class="language-clojure">(require '[promesa.exec :as px])

@(-&gt; (p/delay 100 1)
     (p/then inc px/*default-executor*)
     (p/then inc px/*default-executor*))
;; =&gt; 3
</code></pre>
<p>This will schedule a separate task for each chained callback, making the whole system more responsive because you are no longer executing big blocking functions; instead you are executing many small tasks.</p>
<p>The <code>px/*default-executor*</code> is a <code>ForkJoinPool</code> instance that is highly optimized for lots of small tasks.</p>
<p>On JDK19 with Preview enabled you will also have the <code>px/*vthread-executor*</code> that is an instance of <em>Virtual Thread per task</em> executor.</p>
<h2><a href="#scheduling-executors" id="scheduling-executors"></a>Scheduling &amp; Executors</h2>
<p>Additionally to the <em>promise</em> abstraction, <strong>promesa</strong> library comes with many helpers and factories for execution and scheduling of tasks for asynchronous execution.</p>
<p>Although this API works in the JS runtime and some of the function has general utility, the main target is the JVM platform.</p>
<h3><a href="#async-tasks" id="async-tasks"></a>Async Tasks</h3>
<p>Firstly, lets define <strong>async task</strong>: a function that is executed out of current flow using a different thread. Here, <strong>promesa</strong> library exposes mainly two functions:</p>
<ul>
<li><code>promesa.exec/run!</code>: useful when you want run a function in a different thread and you don’t care abour the return value; it returns a promise that will be fullfilled when the callback terminates.</li>
<li><code>promesa.exec/submit!</code> useful when you want run a function in a different thread and you need the return value; it returns a promise that will be fullfilled with the return value of the function.</li>
</ul>
<p>Let see some examples:</p>
<pre><code class="language-clojure">(require '[promesa.exec :as px])


@(px/run! (fn []
            (prn "I'm running in different thread")
            1))
;; =&gt; nil

@(px/submit! (fn []
               (prn "I'm running in different thread")
               1))
;; =&gt; 1
</code></pre>
<p>The both functions optionally accepts as first argument an executor instance that allows specify the executor where you want execute the specified function. If no executor is provided, the default one is used (binded on the <code>promesa.exec/*default-executor*</code> dynamic var).</p>
<p>Also, in both cases, the returned promise is cancellable, so if for some reason the function is still not execued, the cancellation will prevent the execution. You can cancel a cancellable promise with <code>p/cancel!</code> function.</p>
<h3><a href="#delayed-tasks" id="delayed-tasks"></a>Delayed Tasks</h3>
<p>This consists in a simple helper that allows scheduling execution of a function after some amount of time.</p>
<pre><code class="language-clojure">(require '[promesa.exec :as exec])
(exec/schedule! 1000 (fn []
                       (println "hello world")))
</code></pre>
<p>This example shows you how you can schedule a function call to be executed 1 second in the future. It works the same way for both Clojure and ClojureScript.</p>
<p>The tasks can be cancelled using its return value:</p>
<pre><code class="language-clojure">(def task (exec/schedule! 1000 #(do-stuff)))

(p/cancel! task)
</code></pre>
<p>The execution model depends on the platform: on the <strong>JVM</strong> a default scheduler executor is used and the the scheduled function will be executed in different thread; on <strong>JS</strong> runtime the function will be executed in a <em>microtask</em>.</p>
<h3><a href="#executors-factories" id="executors-factories"></a>Executors Factories</h3>
<p>A collection of factories function for create executors instances (JVM only):</p>
<ul>
<li><code>px/cached-executor</code>: creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available.</li>
<li><code>px/fixed-executor</code>: creates a thread pool that reuses a fixed number of threads operating off a shared unbounded queue.</li>
<li><code>px/single-executor</code>: creates an Executor that uses a single worker thread operating off an unbounded queue</li>
<li><code>px/scheduled-executor</code>: creates a thread pool that can schedule commands to run after a given delay, or to execute periodically.</li>
<li><code>px/forkjoin-executor</code>: creates a thread pool that maintains enough threads to support the given parallelism level, and may use multiple queues to reduce contention.</li>
</ul>
<p>Since v9.0.x there are new factories that uses the JDK&gt;=19 preview API:</p>
<ul>
<li><code>px/thread-per-task-executor</code>: creates an Executor that starts a new Thread for each task.</li>
<li><code>px/vthread-per-task-executor</code>: creates an Executor that starts a new virtual Thread for each task.</li>
</ul>
<h3><a href="#helpers" id="helpers"></a>Helpers</h3>
<h4><a href="#pmap-experimental" id="pmap-experimental"></a><code>pmap</code> (experimental)</h4>
<p>This is a simplified <code>clojure.core/pmap</code> analogous function that allows execute a potentially computationally expensive or io bound functions in parallell.</p>
<p>It returns a lazy chunked seq (uses the clojure’s default chunk size: 32) and the maximum parallelism is determined by the provided executor.</p>
<p>Example:</p>
<pre><code class="language-clojure">(defn slow-inc
  [x]
  (Thread/sleep 1000)
  (inc x))

(time
 (doall
  (px/pmap slow-inc (range 10))))

;; "Elapsed time: 2002.724345 msecs"
;; =&gt; (1 2 3 4 5 6 7 8 9 10)

(time
 (doall
  (map slow-inc (range 10))))

;; Elapsed time: 10001.912614 msecs"
;; =&gt; (1 2 3 4 5 6 7 8 9 10)
</code></pre>
<h4><a href="#with-executor-macro-experimental" id="with-executor-macro-experimental"></a><code>with-executor</code> macro (experimental)</h4>
<p>This allows run a scoped code with the <code>px/*default-executor*</code> binded to the provided executor. The provided executor can be a function for lazy executor instantiation.</p>
<p>It optionally accepts metadata on the executor part for indicate:</p>
<ul>
<li><code>^:shutdown</code>: shutdown the pool before return</li>
<li><code>^:interrupt</code>: shutdown and interrupt before return</li>
</ul>
<p>There an example on how you can customize the executor for <strong>pmap</strong>:</p>
<pre><code class="language-clojure">(time
 (px/with-executor ^:shutdown (px/fixed-executor :parallelism 2)
   (doall (px/pmap slow-inc (range 10)))))

;; "Elapsed time: 5004.506274 msecs"
;; =&gt; (1 2 3 4 5 6 7 8 9 10)
</code></pre>
<h2><a href="#execution-patterns" id="execution-patterns"></a>Execution patterns</h2>
<h3><a href="#channels-csp" id="channels-csp"></a>Channels (CSP)</h3>
<h4><a href="#introduction" id="introduction"></a>Introduction</h4>
<p>Is’s a <a href="https://github.com/clojure/core.async">core.async</a> alternative that laverages JDK19 Virtual Threads; therefore, it is mainly available in the JVM. It combines a new and simplified channel implementation, JDK virtual thrads and composability of promises (CompletableFuture’s).</p>
<p>The main highlights and differences with <a href="https://github.com/clojure/core.async">core.async</a> are:</p>
<ul>
<li><strong>There are no macro transformations</strong>, the <code>go</code> macro is a convenient alias for <code>p/vthread</code> (or <code>p/thread</code> when vthreads are not available); there are not limitation on using blocking calls inside <code>go</code> macro neither many other inconveniences of core.async go macro, mainly thanks to the JDK19 with preview enabled Virtual Threads.</li>
<li><strong>No callbacks</strong>, functions returns promises or blocks.</li>
<li><strong>No take/put limits</strong>; you can attach more than 1024 pending tasks to a channel.</li>
<li><strong>Simplier mental model</strong>, there are no differences between parking and blocking operations.</li>
<li><strong>Analgous performance</strong>; in my own stress tests it has the same performance as core.async.</li>
</ul>
<p>There are also some internal differences that you should know:</p>
<ul>
<li>the promesa implementation cancells immediatelly all pending puts when channel is closed in contrast to core.async that leaves them operative until all puts are succeded.</li>
<li>the promesa implementation takes a bit less grandular locking than core.async, but on the end it should not have any effect on the final performance or usability.</li>
</ul>
<p><strong>The promesa channel and csp patterns implementation do not intend to be a replacement for core.async; and there are cases where <a href="https://github.com/clojure/core.async">core.async</a> is preferable; the main usage target for promesa channels and csp patterns implementation is for JVM based backends with JDK&gt;=19.</strong></p>
<p><strong>NOTE:</strong> Although the main focus is the use in JVM, where is all the potential; the channel implementation and all internal buffers are implemented in CLJC. This means that, if there is interest, we can think about exposing channels api using promises. In any case, <em>the usefulness of channel implementation in CLJS remains to be seen.</em></p>
<h4><a href="#getting-started" id="getting-started"></a>Getting Started</h4>
<p>TODO</p>
<h3><a href="#bulkhead" id="bulkhead"></a>Bulkhead</h3>
<p>In general, the goal of the bulkhead pattern is to avoid faults in one part of a system to take the entire system down. The bulkhead implementation in <strong>promesa</strong> limits the number of concurrent calls.</p>
<p>This <a href="(https://stackoverflow.com/questions/30391809/what-is-bulkhead-pattern-used-by-hystrix)">SO answer</a> explains the concept very well.</p>
<p>So lets stat with an example:</p>
<pre><code class="language-clojure">(require '[promesa.exec.bulkhead :as pxb]
         '[promesa.exec :as px])

;; All parameters are optional and have default value
(def instance (pxb/create :concurrency 1
                          :queue-size 16
                          :executor px/*default-executor*))

@(px/submit! instance (fn []
                        (Thread/sleep 1000)
                        1))
;; =&gt; 1
</code></pre>
<p>At first glance, this seems like an executor instance because it resembles the same API (aka `px/submit! call). And it proxies all submits to the provided executor (or the default one if not provided).</p>
<p>When you submits a task to it, it does the following:</p>
<ul>
<li>Checkes if concurrency limit is not reached, if not, proceed to execute the function in the underlying executor.</li>
<li>If concurrency limit is reached, it queues the execution until other tasks are finished.</li>
<li>If queue limit is reached, the returned promise will be automatically rejected with an exception indicating that queue limit reached.</li>
</ul>
<p>This allows control the concurrency and the queue size on access to some resource.</p>
<p>NOTES:</p>
<ul>
<li><em>As future improvements we consider adding an option for delimit the <strong>max wait</strong> and cancel/reject tasks after some timeout.</em></li>
<li><em>For now it is implemented only on JVM but I think is pretty easy to implement on CLJS, so if there are some interest on it, feel free to open and issue for just show interest or discuss how it can be contributed.</em></li>
</ul>
<h2><a href="#performance-overhead" id="performance-overhead"></a>Performance overhead</h2>
<p><em>promesa</em> is a lightweight abstraction built on top of native facilities (<code>CompletableFuture</code> in the JVM and <code>js/Promise</code> in JavaScript). Internally we make heavy use of protocols in order to expose a polymorphic and user friendly API, and this has little overhead on top of raw usage of <code>CompletableFuture</code> or <code>Promise</code>.</p>
<h2><a href="#contributing" id="contributing"></a>Contributing</h2>
<p>Unlike Clojure and other Clojure contrib libs, this project does not have many restrictions for contributions. Just open an issue or pull request.</p>
<h3><a href="#get-the-code" id="get-the-code"></a>Get the Code</h3>
<p><em>promesa</em> is open source and can be found on <a href="https://github.com/funcool/promesa">github</a>.</p>
<p>You can clone the public repository with this command:</p>
<pre><code>git clone https://github.com/funcool/promesa
</code></pre>
<h3><a href="#run-tests" id="run-tests"></a>Run tests</h3>
<p>To run the tests execute the following:</p>
<p>For the JVM platform:</p>
<pre><code>clojure -X:dev:test
</code></pre>
<p>And for JS platform:</p>
<pre><code>npm install
npm test
</code></pre>
<p>You will need to have Node.js installed on your system.</p>
<h3><a href="#license" id="license"></a>License</h3>
<p><em>promesa</em> is licensed under MPL-2.0 license:</p>
<pre><code>This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at http://mozilla.org/MPL/2.0/.

Copyright (c) Andrey Antukh &lt;niwi@niwi.nz&gt;
</code></pre>
</div></div></div></body></html>